<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <style type="text/css">
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
    </style>
    <script id="shader-fs" type="x-shader/x-fragment">
        varying lowp vec4 vColor;

        void main(void) {
            gl_FragColor = vColor;
        }
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec4 aVertexColor;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying lowp vec4 vColor;
        
        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vColor = aVertexColor;
        }
    </script>
    <script type="text/javascript" src="glUtils.js"></script>

    <!--
    <script type="text/javascript" src="kinematics_problems.js"></script> 
    -->
</head>
<body>
    <div style="width: 350px; height: 800px; border: 0px solid red; position: absolute; top: 10px; left: 10px;">
            q1 [deg] <input type="text" id="o1value" value="0" />
            <input type="range" id="o1" name="points" min="-180" max="180" value="90" oninput="updateO1(this.value)" />
            q2 [deg]<input type="text" id="o2value" value="0" />
            <input type="range" id="o2" name="points" min="-180" max="180" value="-90" onchange="updateO2(this.value)" />
            q3 [deg]<input type="text" id="o3value" value="0" />
            <input type="range" id="o3" name="points" min="-180" max="180" value="90" onchange="updateO3(this.value)" />
            q4 [deg]<input type="text" id="o4value" value="0" />
            <input type="range" id="o4" name="points" min="-180" max="180" value="-90" onchange="updateO4(this.value)" />
            q5 [deg]<input type="text" id="o5value" value="0" />
            <input type="range" id="o5" name="points" min="-180" max="180" value="90" onchange="updateO5(this.value)" />
            q6 [deg]<input type="text" id="o6value" value="0" />
            <input type="range" id="o6" name="points" min="-180" max="180" value="-90" onchange="updateO6(this.value)" />
            
            <div style="width: 400px; position: absolute; top: 0px; left: 400px;">
                <canvas id="myCanvasXY" width="400" height="400" style="border: 1px solid black;"></canvas>
            </div>
            <div style="width: 400px; position: absolute; top: 0px; left: 802px;">
                <canvas id="myCanvasYZ" width="400" height="400" style="border: 1px solid black;"></canvas>
            </div>
            <div style="width: 400px; position: absolute; top: 402px; left: 400px;">
                <canvas id="myCanvasXZ" width="400" height="400" style="border: 1px solid black;"></canvas>
            </div>
            <div onload="start()" style="width: 400px; position: absolute; top: 402px; left: 802px;">
                <canvas id="xyz" width="400" height="400" style="border: 1px solid black;"></canvas>
            </div>
    </div>
        <script type="text/javascript">

            var gl;
            var horizAspect = 400.0/400.0;
            var mvMatrix;
            var shaderProgram;

            var squareRotation = 1.0;
            var lastSquarUpdateTime = 0;
            var squarXOffset = 0;
            var squarYOffset = 0;
            var squarZOffset = 0;
            var xIncValue = 0.2;
            var yIncValue = 0.4;
            var zIncValue = 0.3;

            var squareVerticesBuffer;
            var squareVerticesColorBuffer;
            var vertexPositionAttribute;
            var vertexColorAttribute;

            function xRotation(angle) {
                var c = Math.cos(angle * 180 / Math.PI);
                var s = Math.sin(angle * 180 / Math.PI);
                return [
                    1, 0, 0, 0,
                    0, c, s, 0,
                    0, -s, c, 0,
                    0, 0, 0, 1
                ];
            }

            function yRotation(angle) {
                var c = Math.cos(angle * 180 / Math.PI);
                var s = Math.sin(angle * 180 / Math.PI);
                return [
                    c, 0, -s, 0,
                    0, 1, 0, 0,
                    s, 0, c, 0,
                    0, 0, 0, 1
                ];
            }

            function zRotation(angle) {
                var c = Math.cos(angle * 180 / Math.PI);
                var s = Math.sin(angle * 180 / Math.PI);
                return [
                    [c, -s, 0, 0],
                    [s, c, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                ];
            }

            var mvMatrixStack = [];

            function mvPushMatrix(m) {
                if (m) {
                    mvMatrixStack.push(m.dup());
                    mvMatrix = m.dup();
                } else {
                    mvMatrixStack.push(mvMatrix.dup());
                }
            }

            function mvPopMatrix() {
                if (!mvMatrixStack.length) {
                    trow("Cant pop matrix!");
                }

                mvMatrix = mvMatrixStack.pop();
                return mvMatrix;
            }

            function mvRotate(angle, v) {
                var inRadians = angle * Math.PI / 180;
                var m = Matrix.Rotation(inRadians, $V(v[0], v[1], v[2])).ensure4x4();
                multMatrix(m);
            }

            function loadIdentity() {
                mvMatrix = Matrix.I(4);
            }

            function multMatrix(m) {
                mvMatrix = mvMatrix.x(m);
            }

            function mvTranslate(v) {
                multMatrix(Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4());
            }

            function setMatrixUniforms() {
                var pUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
                gl.uniformMatrix4fv(pUniform, false, new Float32Array(perspectiveMatrix.flatten()));

                var mvUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
                gl.uniformMatrix4fv(mvUniform, false, new Float32Array(mvMatrix.flatten()));
            }

            function drawScene() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                perspectiveMatrix = makePerspective(45, 400.0/400.0, 0.1, 100.0);

                loadIdentity();
                mvTranslate([0.0, 0.0, -4.0]);
                mvPushMatrix();
               // mvRotate(squareRotation, [0,0,1]);

                mvPopMatrix();
  
                var currentTime = (new Date).getTime();
                if (lastSquarUpdateTime) {
                    var delta = currentTime - lastSquarUpdateTime;
                    squareRotation += (30 * delta) / 1000.0;
                }
                lastSquarUpdateTime = currentTime;
                
                squarXOffset += xIncValue * ((30 * delta) / 1000.0);
                squarYOffset += yIncValue * ((30 * delta) / 1000.0);
                squarZOffset += zIncValue * ((30 * delta) / 1000.0);
                if (Math.abs(squarYOffset) > 2.5) {
                    xIncValue = -xIncValue;
                    yIncValue = -yIncValue;
                    zIncValue = -zIncValue;
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesColorBuffer);
                gl.vertexAttribPointer(vertexColorAttribute, 1, gl.FLOAT, false, 0, 0);                
                setMatrixUniforms();
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                mvTranslate([squarXOffset, squarYOffset, squarZOffset]);

            }

            function initBuffers() {
                var verticesZ = [
                    0.2, 0.2, 0.0,
                    -0.2, 0.2, 0.0,
                    0.2, -0.2, 0.0,
                    -0.2, -0.2, 0.0,
                ];
                var colors = [
                    0.0, 0.0, 0.0, 0.0
                    ];

                squareVerticesBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesZ), gl.STATIC_DRAW);

                squareVerticesColorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            }

            function getShader(gl, id) {
                var shaderScript, theSource, currentChild, shader;
                shaderScript = document.getElementById(id);
                console.log(shaderScript);
                if (!shaderScript) {
                    return null;
                }

                theSource = "";
                currentChild = shaderScript.firstChild;

                while (currentChild) {
                    if (currentChild.nodeType == currentChild.TEXT_NODE) {
                        theSource += currentChild.textContent;
                    }
                    currentChild = currentChild.nextSibling;
                }
                if (shaderScript.type == "x-shader/x-fragment") {
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                } else if (shaderScript.type == "x-shader/x-vertex") {
                    shader = gl.createShader(gl.VERTEX_SHADER);
                } else {
                    return null;
                }
                gl.shaderSource(shader, theSource);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert('An error occurred comileing the shader!');
                    return null;
                }
                return shader;
            }

            function initShaders() {
                var fragmentShader = getShader(gl, "shader-fs");
                var vertexShader = getShader(gl, "shader-vs");
                shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                if(!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    alert("Unable to init the shager prgram!");
                }
                gl.useProgram(shaderProgram);
                vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
                gl.enableVertexAttribArray(vertexColorAttribute);
            }

            function initWebGL(canvas) {
                gl = null;

                try {
                    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                } catch (e) {}
                if (!gl) {
                    alert('Problems is initWebGL!');
                    gl = null;
                }
                return gl;
            }

            function start() {
                var cns = document.getElementById('xyz');
                gl = initWebGL(cns);
                if (gl) {
                    gl.clearColor(1.0, 1.0, 1.0, 1.0);
                    gl.enable(gl.DEPTH_TEST);
                    gl.depthFunc(gl.LEQUAL);
                    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                }
            }

            var N = 7;

            var canvas;
            var context;
            var canvasYZ;
            var contextYZ;
            var canvasXZ;
            var contextXZ;
            var x;
            var y;
            var zoom = 1;
            canvas = document.getElementById('myCanvasXY');
            context = canvas.getContext('2d');
            canvasYZ = document.getElementById('myCanvasYZ');
            contextYZ = canvasYZ.getContext('2d');
            canvasXZ = document.getElementById('myCanvasXZ');
            contextXZ = canvasXZ.getContext('2d');
            x = canvas.width;
            y = canvas.height;
            color = ['red', 'blue', 'green', 'pink', 'yellow', 'orange', 'black'];
            context.strokeStyle = color[2];

            // just need, lol
            var aa = new Array();
            var ni = 4;
            var nj = 4;
            res = new Array();
            for (var i = 0; i < ni; i++) {
                res[i] = new Array();
                for (var j = 0; j < nj; j++) {
                    res[i][j] = 0;
                }
            }
            for (var i = 0; i < 7; i++) {
                aa[i] = res;
            }
            // end of just need, lol

            var l = 20;

            var a =     [0,l,0,0,0,0,0];
            var alpha = [90,0,-90,90,-90,0,90];
            var d =     [l,0,0,2*l,0,2*l,0];
            for (var i = 0; i < N; i++) {
                alpha[i] *= Math.PI / 180;
            }


            centerX = x / 2;
            centerY = y / 2;
            prevX = centerX;
            prevY = centerY;



            function draw(c, res, ax1, ax2, dek) {
                c.lineWidth = 1;
                c.clearRect(0, 0, x, y);
                c.strokeStyle = 'green';
                c.lineWidth = 1;
                c.beginPath();
                c.moveTo(10,10);
                c.lineTo(30,10);
                c.moveTo(10,10);
                c.lineTo(10,30);
                cx = '';
                switch(ax1) {
                    case 0: cx = 'X'; break;
                    case 1: cx = 'Y'; break;
                    case 2: cx = 'Z'; break;
                    default: cx = 'I HAVE SOME PROBLEMS!'
                }
                c.fillText(cx,30,13);
                cy = '';
                switch(ax2) {
                    case 0: cy = 'X'; break;
                    case 1: cy = 'Y'; break;
                    case 2: cy = 'Z'; break;
                    default: cy = 'I HAVE SOME PROBLEMS!'
                }
                c.fillText(cy,7,40);
                c.stroke();

                // legenda
                c.lineWidth = 1;
                
                for (var i = 1; i < N+1; i++) {
                    c.lineWidth += 1;
                    c.beginPath();
                    c.strokeStyle = color[i-1];
                    c.moveTo(50+40*(i-1),10);
                    var str = 'q' + i;
                    c.fillText(str,50+40*(i-1),20+i);
                    c.lineTo(50+40*i,10);
                    c.stroke();
                }

                //center point                
                c.lineWidth = 1;
                c.beginPath();
                c.strokeStyle = 'black';
                c.ellipse(centerX, centerY, 5,5,0,0,7);
                c.stroke();

                
                c.lineWidth = 2;
                prevX = centerX;
                prevY = centerY;
                for (var i = 0; i < dek[0].length; i++) {
                    c.strokeStyle = color[i];
                    c.beginPath();
                    c.moveTo(prevX, prevY);
                    var ix = centerX + dek[ax1][i]*zoom;
                    var iy = centerY + dek[ax2][i]*zoom;
                    if (i == dek[0].length-1) {
                        c.lineWidth = 1;
                    }
                    c.lineTo(ix, iy);
                    c.stroke();
                    prevX = ix;
                    prevY = iy;
                    c.lineWidth += 1;
                }
                c.lineWidth = 1;
                c.strokeStyle = color[7];
                c.beginPath();
                //c.rect(0,0,200,200);
                c.stroke();
                // R vector from 0,0,0 to point M
                c.strokeStyle = 'red';
                c.lineWidth = 1;
                c.beginPath();
                c.moveTo(centerX, centerY);
                c.lineTo(centerX + res[ax1][3], centerY + res[ax2][3]);
                c.stroke();
            }

            function mxm(a, b) {
                res = new Array();
                for (var i = 0; i < a.length; i++) {
                    res[i] = new Array();
                    for (var j = 0; j < b[0].length; j++) {
                        res[i][j] = 0;
                    }
                }
                for (var i = 0; i < b[0].length; i++) {
                    for (var j = 0; j < a.length; j++) {
                        for (var k = 0; k < b.length; k++) {
                            res[j][i] += a[j][k] * b[k][i]; 
                        }
                    }
                }
                return res;
            }

            function mxm1(a, b, m) {
                res = [0, 0, 0];
                for (var i = 0; i < m; i++) {
                    for (var k = 0; k < m; k++) {
                        res[i] += a[k] * b[k][i]; 
                    }
                }
                return res;
            }


            function doMagic() {
                for (var ii = 0; ii < N; ii++) {
                    o1 = document.getElementById('o1').value;
                    o2 = document.getElementById('o2').value;
                    o3 = document.getElementById('o3').value;   
                    o4 = document.getElementById('o4').value;
                    o5 = document.getElementById('o5').value;
                    o6 = document.getElementById('o6').value;
                    o7 = 45;
                    otta =  [o1,o2,o3,o4,o5,o6,o7];
                    for (var i = 0; i < otta.length; i++) {
                        otta[i] *= Math.PI / 180;
                    }

                    Rz = [  [Math.cos(otta[ii]), (-1) * Math.sin(otta[ii]), 0, 0],
                            [Math.sin(otta[ii]), Math.cos(otta[ii]), 0, 0],
                            [0, 0, 1, 0],
                            [0, 0, 0, 1]];

                    Tzd = [ [1, 0, 0, 0],
                            [0, 1, 0, 0],
                            [0, 0, 1, d[ii]],
                            [0, 0, 0, 1]];

                    Txa = [ [1, 0, 0, a[ii]],
                            [0, 1, 0, 0],
                            [0, 0, 1, 0],
                            [0, 0, 0, 1]];

                    Rx = [  [1, 0, 0, 0],
                            [0, Math.cos(alpha[ii]), (-1) * Math.sin(alpha[ii]), 0],
                            [0, Math.sin(alpha[ii]), Math.cos(alpha[ii]), 0],
                            [0, 0, 0, 1]];

                    res = mxm(mxm(mxm(Rz, Tzd), Txa), Rx);
                    aa[ii] = res;
                    //console.log(ii + ' done!');
                }
                console.log("**********************");
                var xi = new Array();
                var yi = new Array();
                var zi = new Array();

                var res = aa[0];
                xi.push(res[0][3]);
                yi.push(res[1][3]);
                zi.push(res[2][3]);
                for (var i = 1; i < N; i++) {
                    res = mxm(res, aa[i]);
                    xi.push(res[0][3]);
                    yi.push(res[1][3]);
                    zi.push(res[2][3]);
                }

                res = mxm(mxm(mxm(mxm(mxm(aa[0], aa[1]), aa[2]), aa[3]), aa[4]),aa[5]);
                xi.push(res[0][3]);
                yi.push(res[1][3]);
                zi.push(res[2][3]);
                // console.log(xi);
                // console.log(yi);
                // console.log(zi);
                var dek = new Array();
                dek.push(xi);
                dek.push(yi);
                dek.push(zi);

                draw(context, res, 0, 1, dek);
                draw(contextYZ, res, 2, 1, dek);
                draw(contextXZ, res, 0, 2, dek);  

                console.log("model...");
                console.log(res[0][3]);
                console.log(res[1][3]);
                console.log(res[2][3]);
 

		context.strokeStyle = 'red';
                context.lineWidth = 1;
                context.beginPath();
                context.moveTo(centerX, centerY);
               // context.lineTo(centerX + res[0][3], centerY + res[1][3]);             var fpeef = mxm(end_eff[1], Reef);
                context.stroke();
            }

            function update_o1() {
                o1 = document.getElementById('o1').value;
                console.log(o1);
            }

            function update_o2() {
                o2 = document.getElementById('o2').value;
            }

            function update_o3() {
                o3 = document.getElementById('o3').value;
            }

            function update_o4() {
                o4 = document.getElementById('o4').value;
            }

            function update_o5() {
                o5 = document.getElementById('o5').value;
            }

            function update_o6() {
                o6 = document.getElementById('o6').value;
            }

            function updateO1(val) {
                document.getElementById('o1value').value = val;
               //document.querySelector('#o1value').value = val;
            }
            function updateO2(val) {
                document.getElementById('o2value').value = val;
            }
            function updateO3(val) {
                document.getElementById('o3value').value = val;
            }
            function updateO4(val) {
                document.getElementById('o4value').value = val;
            }
            function updateO5(val) {
                document.getElementById('o5value').value = val;
            }
            function updateO6(val) {
                document.getElementById('o6value').value = val;
            }

        window.onload = function() {
           /*
	    start();
            initShaders();
            initBuffers();
            drawScene();
            */

            document.body.addEventListener('mousemove', doMagic);
            document.getElementById('o1').addEventListener('mousemove', update_o1); 
            document.getElementById('o2').addEventListener('change', update_o2);
            document.getElementById('o3').addEventListener('change', update_o3);
            document.getElementById('o4').addEventListener('change', update_o4);
            document.getElementById('o5').addEventListener('change', update_o5);
            document.getElementById('o6').addEventListener('change', update_o6);
        }
    </script>
</body>
</html>